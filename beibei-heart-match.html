<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"        .game-board {
            display: grid;
            gap: 0.5px;       /* æ›´ç´§å¯†çš„é—´è·0.5px */
            background: rgba(255, 182, 193, 0.5);
            padding: 8px;     
            border-radius: 15px;
            border: 2px solid #ffb6c1;
            margin-bottom: 15px;
            justify-content: center;
        }width=device-width, initial-scale=1.0">
    <title>è““è““çš„çˆ±å¿ƒè¿è¿çœ‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #ffeef8, #ffe0f0, #ffd1e8);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 15px 35px rgba(255, 105, 180, 0.3);
            border: 3px solid #ff69b4;
            max-width: 800px;  /* å¢åŠ æœ€å¤§å®½åº¦ */
            width: 100%;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-title {
            color: #ff1493;
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(255, 105, 180, 0.3);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .info-item {
            background: linear-gradient(45deg, #ff69b4, #ff1493);
            color: white;
            padding: 8px 15px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 3px 10px rgba(255, 105, 180, 0.4);
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .control-btn {
            background: linear-gradient(45deg, #ff69b4, #ff1493);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 105, 180, 0.4);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 105, 180, 0.6);
        }

        .control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .game-board {
            display: grid;
            gap: 2px;         /* é»˜è®¤é—´è·ï¼Œå°†ç”±JSåŠ¨æ€è®¾ç½® */
            background: rgba(255, 182, 193, 0.5);
            padding: 8px;     
            border-radius: 15px;
            border: 2px solid #ffb6c1;
            margin-bottom: 15px;
            justify-content: center;
            align-content: center;
        }

        .cell {
            /* ç§»é™¤å›ºå®šå°ºå¯¸ï¼Œæ”¹ç”¨aspect-ratioä¿æŒæ­£æ–¹å½¢ */
            aspect-ratio: 1 / 1;
            background: linear-gradient(145deg, #ffe4e1, #ffc0cb);
            border: 1px solid #ffb6c1;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            /* å­—ä½“å¤§å°å°†ç”±JSåŠ¨æ€è®¾ç½® */
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .cell:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(255, 105, 180, 0.6);
        }

        .cell.selected {
            background: linear-gradient(145deg, #ff69b4, #ff1493);
            color: white;
            border-color: #ff1493;
            transform: scale(1.15);
            box-shadow: 0 0 20px rgba(255, 20, 147, 0.8);
        }

        .cell.matched {
            background: linear-gradient(145deg, #90ee90, #32cd32);
            border-color: #228b22;
            animation: matchAnimation 0.6s ease forwards;
            pointer-events: none;
        }

        .cell.hint {
            animation: hintAnimation 1s ease infinite;
        }

        @keyframes matchAnimation {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3) rotate(10deg); opacity: 1; }
            100% { transform: scale(0); opacity: 0; visibility: hidden; }
        }

        @keyframes hintAnimation {
            0%, 100% { box-shadow: 0 0 0 rgba(255, 215, 0, 0.7); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.9); }
        }

        .connection-line {
            position: absolute;
            background: linear-gradient(90deg, #ff69b4, #ff1493, #ff69b4);
            height: 4px;
            border-radius: 2px;
            z-index: 10;
            opacity: 0.8;
            animation: lineAnimation 0.5s ease;
        }

        @keyframes lineAnimation {
            0% { opacity: 0; transform: scaleX(0); }
            100% { opacity: 0.8; transform: scaleX(1); }
        }

        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ff69b4;
            border-radius: 50%;
            pointer-events: none;
            animation: particleAnimation 1s ease-out forwards;
        }

        @keyframes particleAnimation {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0) translateY(-50px);
            }
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            border: 3px solid #ff69b4;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
        }

        .game-over h2 {
            color: #ff1493;
            margin-bottom: 15px;
            font-size: 24px;
        }

        .game-over p {
            color: #666;
            margin-bottom: 20px;
            font-size: 16px;
        }

        .difficulty-selector {
            text-align: center;
            margin-bottom: 15px;
        }

        .difficulty-btn {
            background: linear-gradient(45deg, #ffb6c1, #ff69b4);
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 0 5px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .difficulty-btn.active {
            background: linear-gradient(45deg, #ff1493, #dc143c);
            transform: scale(1.1);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 182, 193, 0.5);
            border-radius: 4px;
            margin-bottom: 15px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff69b4, #ff1493);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">ğŸ’– è““è““çš„çˆ±å¿ƒè¿è¿çœ‹ ğŸ’–</h1>
            
            <div class="difficulty-selector">
                <span style="color: #ff1493; font-weight: bold;">éš¾åº¦é€‰æ‹©ï¼š</span>
                <button class="difficulty-btn active" onclick="setDifficulty('easy')">ç®€å• 8x6</button>
                <button class="difficulty-btn" onclick="setDifficulty('normal')">æ™®é€š 10x8</button>
                <button class="difficulty-btn" onclick="setDifficulty('hard')">å›°éš¾ 12x10</button>
            </div>
        </div>

        <div class="game-info">
            <div class="info-item">â±ï¸ æ—¶é—´: <span id="timer">00:00</span></div>
            <div class="info-item">ğŸ’¯ åˆ†æ•°: <span id="score">0</span></div>
            <div class="info-item">ğŸ¯ å‰©ä½™: <span id="remaining">0</span>å¯¹</div>
            <div class="info-item">ğŸ’¡ æç¤º: <span id="hints">3</span></div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="game-controls">
            <button class="control-btn" onclick="newGame()">ğŸ†• æ–°æ¸¸æˆ</button>
            <button class="control-btn" onclick="useHint()" id="hintBtn">ğŸ’¡ æç¤º</button>
            <button class="control-btn" onclick="shuffleBoard()" id="shuffleBtn">ğŸ”€ é‡æ’</button>
            <button class="control-btn" onclick="pauseGame()" id="pauseBtn">â¸ï¸ æš‚åœ</button>
        </div>

        <div class="game-board" id="gameBoard"></div>
    </div>

    <div class="game-over" id="gameOverModal">
        <h2 id="gameOverTitle">ğŸ‰ æ­å–œå®Œæˆï¼</h2>
        <p id="gameOverText">ä½ å¤ªæ£’äº†ï¼</p>
        <p id="gameOverStats"></p>
        <div style="margin-top: 20px;">
            <button class="control-btn" onclick="newGame(); closeGameOver()">ğŸ†• å†æ¥ä¸€å±€</button>
            <button class="control-btn" onclick="closeGameOver()">âŒ å…³é—­</button>
        </div>
    </div>

    <script>
        // æ¸¸æˆé…ç½®
        const difficulties = {
            easy: { rows: 6, cols: 8, pairs: 20, timeBonus: 200 },     // 8Ã—6 = 48æ ¼ï¼Œ20å¯¹ç¬¦å·
            normal: { rows: 8, cols: 10, pairs: 35, timeBonus: 250 },  // 10Ã—8 = 80æ ¼ï¼Œ35å¯¹ç¬¦å·  
            hard: { rows: 10, cols: 12, pairs: 50, timeBonus: 300 }    // 12Ã—10 = 120æ ¼ï¼Œ50å¯¹ç¬¦å·
        };

        let currentDifficulty = 'easy';
        let gameBoard = [];
        let selectedCells = [];
        let matchedPairs = 0;
        let totalPairs = 0;
        let score = 0;
        let hints = 3;
        let shuffles = 2;
        let gameStartTime = 0;
        let gameTimer = null;
        let isPaused = false;

        // çˆ±å¿ƒç¬¦å·é›†åˆ - æ‰©å±•ç‰ˆæœ¬ï¼Œæ”¯æŒæ›´å¤§çš„æ¸¸æˆæ¿
        const heartSymbols = [
            'ğŸ’–', 'ğŸ’•', 'ğŸ’—', 'ğŸ’“', 'ğŸ’', 'ğŸ’˜', 'ğŸ’Œ', 'ğŸ’Ÿ',
            'â¤ï¸', 'ğŸ§¡', 'ğŸ’›', 'ğŸ’š', 'ğŸ’™', 'ğŸ’œ', 'ğŸ¤', 'ğŸ–¤',
            'ğŸŒ¹', 'ğŸŒ¸', 'ğŸŒº', 'ğŸŒ»', 'ğŸŒ·', 'ğŸ¥€', 'ğŸ€', 'ğŸ’',
            'â­', 'âœ¨', 'ğŸŒŸ', 'ğŸ’«', 'ğŸ¦‹', 'ğŸŒˆ', 'ğŸŒ¼', 'ğŸŒµ',
            'ğŸ€', 'ğŸŒ¿', 'ğŸŒ±', 'ğŸŒ¾', 'ğŸƒ', 'ğŸŒ³', 'ğŸŒ²', 'ğŸ„',
            'â£ï¸', 'ğŸ’‹', 'ğŸ‘‘', 'ğŸ’', 'ğŸ”®', 'ğŸª', 'ğŸ­', 'ğŸ¨',
            'ğŸµ', 'ğŸ¶', 'ğŸ¸', 'ğŸ¹', 'ğŸº', 'ğŸ»', 'ğŸ¥°', 'ğŸ˜'
        ];

        // éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆç”¨äºéŸ³æ•ˆï¼‰
        let audioContext;

        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.log('éŸ³é¢‘ä¸æ”¯æŒ');
            }
        }

        function playSound(type) {
            if (!audioContext) return;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            switch (type) {
                case 'select':
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'match':
                    oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(1500, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                case 'complete':
                    // èƒœåˆ©éŸ³æ•ˆ
                    [1000, 1200, 1500, 2000].forEach((freq, i) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.setValueAtTime(freq, audioContext.currentTime + i * 0.1);
                        gain.gain.setValueAtTime(0.1, audioContext.currentTime + i * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + i * 0.1 + 0.2);
                        osc.start(audioContext.currentTime + i * 0.1);
                        osc.stop(audioContext.currentTime + i * 0.1 + 0.2);
                    });
                    return;
            }
        }

        function setDifficulty(level) {
            currentDifficulty = level;
            document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            newGame();
        }

        function initializeGame() {
            initAudio();
            const config = difficulties[currentDifficulty];
            const boardElement = document.getElementById('gameBoard');
            
            console.log('=== æ¸¸æˆåˆå§‹åŒ–è°ƒè¯•ä¿¡æ¯ ===');
            console.log('å½“å‰éš¾åº¦:', currentDifficulty);
            console.log('é…ç½®:', config);
            console.log('æ€»æ ¼å­æ•°:', config.rows * config.cols);
            
            // ç¡®ä¿åœ¨æµ‹é‡å‰æ¸…ç©ºï¼Œé¿å…æ—§å…ƒç´ å½±å“å°ºå¯¸
            boardElement.innerHTML = '';
            
            // ç§»é™¤ä¹‹å‰åŠ¨æ€æ·»åŠ çš„ style æ ‡ç­¾ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
            const oldStyles = document.querySelectorAll('style[data-dynamic]');
            oldStyles.forEach(style => style.remove());
            
            // === âœ¨ å…¨æ–°çš„å“åº”å¼è®¡ç®—é€»è¾‘ âœ¨ ===
            const gap = 2; // å®šä¹‰ä¸€ä¸ªç»Ÿä¸€çš„é—´è·å€¼ (å•ä½: px)
            const boardPadding = 8 * 2; // game-board çš„å·¦å³ padding æ€»å’Œ
            // è·å– game-container çš„å¯ç”¨å®½åº¦
            const containerWidth = document.querySelector('.game-container').clientWidth; 
            // å‡å»æ¸¸æˆæ¿çš„ padding å’Œå®¹å™¨çš„ padding
            const boardAvailableWidth = containerWidth - (20 * 2) - boardPadding;

            // è®¡ç®—æ¯ä¸ªæ ¼å­åº”è¯¥æœ‰çš„å®½åº¦
            let cellSize = Math.floor((boardAvailableWidth - (config.cols - 1) * gap) / config.cols);

            // ä¸ºäº†é˜²æ­¢åœ¨è¶…å¤§å±å¹•ä¸Šæ ¼å­å˜å¾—è¿‡å¤§ï¼Œå¯ä»¥è®¾ç½®ä¸€ä¸ªæœ€å¤§å€¼
            const maxCellSize = 60; // ä¾‹å¦‚ï¼Œæœ€å¤§ä¸è¶…è¿‡60px
            cellSize = Math.min(cellSize, maxCellSize);
            
            // æ ¹æ®æ ¼å­å¤§å°åŠ¨æ€è®¡ç®—å­—ä½“å¤§å°
            let fontSize = Math.floor(cellSize * 0.5);
            
            console.log('å®¹å™¨å®½åº¦:', containerWidth);
            console.log('å¯ç”¨å®½åº¦:', boardAvailableWidth);
            console.log('è®¡ç®—çš„æ ¼å­å¤§å°:', cellSize);
            console.log('è®¡ç®—çš„å­—ä½“å¤§å°:', fontSize);

            // å°†è®¡ç®—å¥½çš„å¸ƒå±€åº”ç”¨åˆ°æ¸¸æˆæ¿
            boardElement.style.gap = `${gap}px`;
            boardElement.style.gridTemplateColumns = `repeat(${config.cols}, ${cellSize}px)`;
            boardElement.style.gridTemplateRows = `repeat(${config.rows}, ${cellSize}px)`;
            
            console.log('è®¾ç½®ç½‘æ ¼:', `repeat(${config.cols}, ${cellSize}px)`);
            // === âœ¨ å“åº”å¼è®¡ç®—é€»è¾‘ç»“æŸ âœ¨ ===
            
            // é‡ç½®æ¸¸æˆçŠ¶æ€
            gameBoard = [];
            selectedCells = [];
            matchedPairs = 0;
            totalPairs = config.pairs;
            score = 0;
            hints = 4;        // é€‚ä¸­çš„æç¤ºæ¬¡æ•°
            shuffles = 3;     // é€‚ä¸­çš„é‡æ’æ¬¡æ•°
            
            // ç”Ÿæˆå›¾æ¡ˆå¯¹ - ç¡®ä¿æœ‰è¶³å¤Ÿçš„ç¬¦å·ç§ç±»
            const symbols = [];
            const availableSymbols = [...heartSymbols]; // å¤åˆ¶ç¬¦å·æ•°ç»„
            
            // éšæœºé€‰æ‹©ä¸é‡å¤çš„ç¬¦å·æ¥ç”Ÿæˆé…å¯¹
            for (let i = 0; i < config.pairs; i++) {
                let symbolIndex;
                if (i < availableSymbols.length) {
                    // å‰é¢ç”¨ä¸é‡å¤çš„ç¬¦å·
                    symbolIndex = Math.floor(Math.random() * availableSymbols.length);
                    const symbol = availableSymbols.splice(symbolIndex, 1)[0];
                    symbols.push(symbol, symbol); // æ·»åŠ ä¸€å¯¹
                } else {
                    // å¦‚æœç¬¦å·ä¸å¤Ÿäº†ï¼Œé‡æ–°ä½¿ç”¨
                    const symbol = heartSymbols[i % heartSymbols.length];
                    symbols.push(symbol, symbol); // æ·»åŠ ä¸€å¯¹
                }
            }
            
            // éšæœºæ‰“ä¹±ç¬¦å·é¡ºåº
            for (let i = symbols.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
            }
            
            // åˆ›å»ºæ¸¸æˆæ¿
            for (let i = 0; i < config.rows * config.cols; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.index = i;
                
                // åŠ¨æ€è®¾ç½®è®¡ç®—å‡ºçš„å­—ä½“å¤§å°
                cell.style.fontSize = `${fontSize}px`;
                
                if (i < symbols.length) {
                    cell.dataset.symbol = symbols[i];
                    cell.textContent = symbols[i];
                    cell.addEventListener('click', () => selectCell(i));
                } else {
                    cell.style.visibility = 'hidden'; // éšè—å¤šä½™çš„æ ¼å­
                }
                
                boardElement.appendChild(cell);
                gameBoard.push(cell);
            }
            
            updateUI();
            startTimer();
        }

        function selectCell(index) {
            if (isPaused) return;
            
            const cell = gameBoard[index];
            if (!cell || cell.classList.contains('matched') || cell.classList.contains('selected')) {
                return;
            }
            
            // æ¸…é™¤æç¤ºæ•ˆæœ
            document.querySelectorAll('.cell').forEach(c => c.classList.remove('hint'));
            
            cell.classList.add('selected');
            selectedCells.push(index);
            playSound('select');
            
            if (selectedCells.length === 2) {
                setTimeout(() => checkMatch(), 300);
            }
        }

        function checkMatch() {
            const [index1, index2] = selectedCells;
            const cell1 = gameBoard[index1];
            const cell2 = gameBoard[index2];
            
            // æ£€æŸ¥å›¾æ¡ˆæ˜¯å¦ç›¸åŒ
            if (cell1.dataset.symbol !== cell2.dataset.symbol) {
                // åŒ¹é…å¤±è´¥
                setTimeout(() => {
                    cell1.classList.remove('selected');
                    cell2.classList.remove('selected');
                }, 500);
                selectedCells = [];
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆè·¯å¾„è¿æ¥
            if (canConnect(index1, index2)) {
                // åŒ¹é…æˆåŠŸ
                cell1.classList.remove('selected');
                cell2.classList.remove('selected');
                cell1.classList.add('matched');
                cell2.classList.add('matched');
                
                // åˆ›å»ºè¿æ¥çº¿åŠ¨ç”»
                drawConnectionLine(cell1, cell2);
                
                // åˆ›å»ºç²’å­æ•ˆæœ
                createParticles(cell1);
                createParticles(cell2);
                
                matchedPairs++;
                score += 100 + (hints * 10); // å‰©ä½™æç¤ºè¶Šå¤šåˆ†æ•°è¶Šé«˜
                
                playSound('match');
                
                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦å®Œæˆ
                if (matchedPairs === totalPairs) {
                    setTimeout(() => gameComplete(), 500);
                }
            } else {
                // æ— æœ‰æ•ˆè·¯å¾„è¿æ¥
                setTimeout(() => {
                    cell1.classList.remove('selected');
                    cell2.classList.remove('selected');
                }, 500);
            }
            
            selectedCells = [];
            updateUI();
        }

        function canConnect(index1, index2) {
            const config = difficulties[currentDifficulty];
            const pos1 = { row: Math.floor(index1 / config.cols), col: index1 % config.cols };
            const pos2 = { row: Math.floor(index2 / config.cols), col: index2 % config.cols };
            
            // æ­£å¸¸è¿æ¥è§„åˆ™
            // æ£€æŸ¥ç›´çº¿è¿æ¥ï¼ˆ0ä¸ªè½¬å¼¯ï¼‰
            if (isDirectPath(pos1, pos2, config)) return true;
            
            // æ£€æŸ¥ä¸€ä¸ªè½¬å¼¯çš„è¿æ¥
            if (isOneCornerPath(pos1, pos2, config)) return true;
            
            // æ£€æŸ¥ä¸¤ä¸ªè½¬å¼¯çš„è¿æ¥
            if (isTwoCornerPath(pos1, pos2, config)) return true;
            
            return false;
        }
        
        function isDirectPath(pos1, pos2, config) {
            // åŒè¡Œ
            if (pos1.row === pos2.row) {
                const minCol = Math.min(pos1.col, pos2.col);
                const maxCol = Math.max(pos1.col, pos2.col);
                for (let col = minCol + 1; col < maxCol; col++) {
                    const index = pos1.row * config.cols + col;
                    // æ£€æŸ¥è·¯å¾„ä¸­æ˜¯å¦æœ‰æœªè¢«åŒ¹é…çš„æ ¼å­ï¼ˆæœ‰symbolä¸”æœªmatchedçš„æ ¼å­æ˜¯éšœç¢ï¼‰
                    if (gameBoard[index] && gameBoard[index].dataset.symbol && !gameBoard[index].classList.contains('matched')) {
                        return false;
                    }
                }
                return true;
            }
            
            // åŒåˆ—
            if (pos1.col === pos2.col) {
                const minRow = Math.min(pos1.row, pos2.row);
                const maxRow = Math.max(pos1.row, pos2.row);
                for (let row = minRow + 1; row < maxRow; row++) {
                    const index = row * config.cols + pos1.col;
                    // æ£€æŸ¥è·¯å¾„ä¸­æ˜¯å¦æœ‰æœªè¢«åŒ¹é…çš„æ ¼å­ï¼ˆæœ‰symbolä¸”æœªmatchedçš„æ ¼å­æ˜¯éšœç¢ï¼‰
                    if (gameBoard[index] && gameBoard[index].dataset.symbol && !gameBoard[index].classList.contains('matched')) {
                        return false;
                    }
                }
                return true;
            }
            
            return false;
        }
        
        function isOneCornerPath(pos1, pos2, config) {
            // å°è¯•æ‹ç‚¹1: (pos1.row, pos2.col)
            const corner1 = { row: pos1.row, col: pos2.col };
            const corner1Index = corner1.row * config.cols + corner1.col;
            
            // æ£€æŸ¥æ‹ç‚¹æ˜¯å¦å¯ä»¥é€šè¿‡ï¼ˆæ²¡æœ‰symbolæˆ–å·²ç»matchedçš„æ ¼å­å¯ä»¥é€šè¿‡ï¼‰
            if (corner1Index >= 0 && corner1Index < gameBoard.length) {
                const corner1Cell = gameBoard[corner1Index];
                const canPassCorner1 = !corner1Cell.dataset.symbol || corner1Cell.classList.contains('matched');
                
                if (canPassCorner1 && isDirectPath(pos1, corner1, config) && isDirectPath(corner1, pos2, config)) {
                    return true;
                }
            }
            
            // å°è¯•æ‹ç‚¹2: (pos2.row, pos1.col)
            const corner2 = { row: pos2.row, col: pos1.col };
            const corner2Index = corner2.row * config.cols + corner2.col;
            
            // æ£€æŸ¥æ‹ç‚¹æ˜¯å¦å¯ä»¥é€šè¿‡ï¼ˆæ²¡æœ‰symbolæˆ–å·²ç»matchedçš„æ ¼å­å¯ä»¥é€šè¿‡ï¼‰
            if (corner2Index >= 0 && corner2Index < gameBoard.length) {
                const corner2Cell = gameBoard[corner2Index];
                const canPassCorner2 = !corner2Cell.dataset.symbol || corner2Cell.classList.contains('matched');
                
                if (canPassCorner2 && isDirectPath(pos1, corner2, config) && isDirectPath(corner2, pos2, config)) {
                    return true;
                }
            }
            
            return false;
        }
        
        function isTwoCornerPath(pos1, pos2, config) {
            // å°è¯•æ°´å¹³æ‰©å±•
            for (let col = 0; col < config.cols; col++) {
                if (col === pos1.col || col === pos2.col) continue;
                
                const mid1 = { row: pos1.row, col: col };
                const mid2 = { row: pos2.row, col: col };
                const mid1Index = mid1.row * config.cols + mid1.col;
                const mid2Index = mid2.row * config.cols + mid2.col;
                
                if (mid1Index >= 0 && mid1Index < gameBoard.length && 
                    mid2Index >= 0 && mid2Index < gameBoard.length) {
                    
                    const mid1Cell = gameBoard[mid1Index];
                    const mid2Cell = gameBoard[mid2Index];
                    const canPassMid1 = !mid1Cell.dataset.symbol || mid1Cell.classList.contains('matched');
                    const canPassMid2 = !mid2Cell.dataset.symbol || mid2Cell.classList.contains('matched');
                    
                    if (canPassMid1 && canPassMid2 &&
                        isDirectPath(pos1, mid1, config) && 
                        isDirectPath(mid1, mid2, config) && 
                        isDirectPath(mid2, pos2, config)) {
                        return true;
                    }
                }
            }
            
            // å°è¯•å‚ç›´æ‰©å±•
            for (let row = 0; row < config.rows; row++) {
                if (row === pos1.row || row === pos2.row) continue;
                
                const mid1 = { row: row, col: pos1.col };
                const mid2 = { row: row, col: pos2.col };
                const mid1Index = mid1.row * config.cols + mid1.col;
                const mid2Index = mid2.row * config.cols + mid2.col;
                
                if (mid1Index >= 0 && mid1Index < gameBoard.length && 
                    mid2Index >= 0 && mid2Index < gameBoard.length) {
                    
                    const mid1Cell = gameBoard[mid1Index];
                    const mid2Cell = gameBoard[mid2Index];
                    const canPassMid1 = !mid1Cell.dataset.symbol || mid1Cell.classList.contains('matched');
                    const canPassMid2 = !mid2Cell.dataset.symbol || mid2Cell.classList.contains('matched');
                    
                    if (canPassMid1 && canPassMid2 &&
                        isDirectPath(pos1, mid1, config) && 
                        isDirectPath(mid1, mid2, config) && 
                        isDirectPath(mid2, pos2, config)) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function drawConnectionLine(cell1, cell2) {
            const rect1 = cell1.getBoundingClientRect();
            const rect2 = cell2.getBoundingClientRect();
            const boardRect = document.getElementById('gameBoard').getBoundingClientRect();
            
            const x1 = rect1.left + rect1.width / 2 - boardRect.left;
            const y1 = rect1.top + rect1.height / 2 - boardRect.top;
            const x2 = rect2.left + rect2.width / 2 - boardRect.left;
            const y2 = rect2.top + rect2.height / 2 - boardRect.top;
            
            const line = document.createElement('div');
            line.className = 'connection-line';
            
            const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            
            line.style.width = length + 'px';
            line.style.left = x1 + 'px';
            line.style.top = y1 + 'px';
            line.style.transform = `rotate(${angle}deg)`;
            line.style.transformOrigin = '0 50%';
            
            document.getElementById('gameBoard').appendChild(line);
            
            setTimeout(() => line.remove(), 500);
        }

        function createParticles(cell) {
            const rect = cell.getBoundingClientRect();
            const boardRect = document.getElementById('gameBoard').getBoundingClientRect();
            
            for (let i = 0; i < 8; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                const x = rect.left + rect.width / 2 - boardRect.left;
                const y = rect.top + rect.height / 2 - boardRect.top;
                
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.animationDelay = (i * 50) + 'ms';
                
                // éšæœºé¢œè‰²
                const colors = ['#ff69b4', '#ff1493', '#ffd700', '#ff6347', '#90ee90'];
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                
                document.getElementById('gameBoard').appendChild(particle);
                
                setTimeout(() => particle.remove(), 1000);
            }
        }

        function useHint() {
            if (hints <= 0 || isPaused) return;
            
            hints--;
            
            // æ¸…é™¤ä¹‹å‰çš„æç¤º
            document.querySelectorAll('.cell').forEach(c => c.classList.remove('hint'));
            
            // å¯»æ‰¾å¯åŒ¹é…ä¸”å¯è¿æ¥çš„ä¸€å¯¹
            const availableCells = gameBoard
                .map((cell, index) => ({ cell, index }))
                .filter(item => !item.cell.classList.contains('matched') && item.cell.dataset.symbol);
            
            for (let i = 0; i < availableCells.length; i++) {
                for (let j = i + 1; j < availableCells.length; j++) {
                    if (availableCells[i].cell.dataset.symbol === availableCells[j].cell.dataset.symbol &&
                        canConnect(availableCells[i].index, availableCells[j].index)) {
                        
                        availableCells[i].cell.classList.add('hint');
                        availableCells[j].cell.classList.add('hint');
                        
                        setTimeout(() => {
                            availableCells[i].cell.classList.remove('hint');
                            availableCells[j].cell.classList.remove('hint');
                        }, 2000);
                        
                        updateUI();
                        return;
                    }
                }
            }
            
            // å¦‚æœæ²¡æ‰¾åˆ°å¯è¿æ¥çš„å¯¹ï¼Œé€€è¿˜æç¤ºæ¬¡æ•°
            hints++;
            alert('å½“å‰æ²¡æœ‰å¯è¿æ¥çš„åŒ¹é…å¯¹ï¼Œè¯·å°è¯•é‡æ–°æ’åˆ—ï¼');
            updateUI();
        }

        function shuffleBoard() {
            if (shuffles <= 0 || isPaused) return;
            
            shuffles--;
            
            // è·å–æ‰€æœ‰æœªåŒ¹é…çš„ç¬¦å·
            const unmatchedSymbols = [];
            gameBoard.forEach(cell => {
                if (!cell.classList.contains('matched') && cell.dataset.symbol) {
                    unmatchedSymbols.push(cell.dataset.symbol);
                }
            });
            
            // éšæœºæ‰“ä¹±
            for (let i = unmatchedSymbols.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [unmatchedSymbols[i], unmatchedSymbols[j]] = [unmatchedSymbols[j], unmatchedSymbols[i]];
            }
            
            // é‡æ–°åˆ†é…ç¬¦å·
            let symbolIndex = 0;
            gameBoard.forEach(cell => {
                if (!cell.classList.contains('matched') && cell.dataset.symbol) {
                    cell.dataset.symbol = unmatchedSymbols[symbolIndex];
                    cell.textContent = unmatchedSymbols[symbolIndex];
                    symbolIndex++;
                }
            });
            
            // æ¸…é™¤é€‰ä¸­çŠ¶æ€
            selectedCells = [];
            document.querySelectorAll('.cell').forEach(c => {
                c.classList.remove('selected', 'hint');
            });
            
            updateUI();
        }

        function pauseGame() {
            isPaused = !isPaused;
            const btn = document.getElementById('pauseBtn');
            
            if (isPaused) {
                clearInterval(gameTimer);
                btn.textContent = 'â–¶ï¸ ç»§ç»­';
                // éšè—æ¸¸æˆæ¿å†…å®¹
                document.querySelectorAll('.cell').forEach(cell => {
                    if (!cell.classList.contains('matched')) {
                        cell.style.opacity = '0.1';
                    }
                });
            } else {
                startTimer();
                btn.textContent = 'â¸ï¸ æš‚åœ';
                // æ˜¾ç¤ºæ¸¸æˆæ¿å†…å®¹
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.style.opacity = '1';
                });
            }
        }

        function startTimer() {
            gameStartTime = Date.now();
            gameTimer = setInterval(() => {
                if (!isPaused) {
                    const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('timer').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);
        }

        function gameComplete() {
            clearInterval(gameTimer);
            
            const elapsed = Math.floor((Date.now() - gameStartTime) / 1000);
            const timeBonus = Math.max(0, difficulties[currentDifficulty].timeBonus - elapsed);
            const finalScore = score + timeBonus + (hints * 50) + (shuffles * 100);
            
            playSound('complete');
            
            document.getElementById('gameOverTitle').textContent = 'ğŸ‰ æ­å–œå®Œæˆï¼';
            document.getElementById('gameOverText').textContent = 'ä½ æ˜¯è¿è¿çœ‹å¤§å¸ˆï¼';
            document.getElementById('gameOverStats').innerHTML = `
                <p>ğŸ† æœ€ç»ˆåˆ†æ•°: <strong style="color: #ff1493;">${finalScore}</strong></p>
                <p>â±ï¸ ç”¨æ—¶: <strong>${Math.floor(elapsed / 60)}:${(elapsed % 60).toString().padStart(2, '0')}</strong></p>
                <p>âš¡ æ—¶é—´å¥–åŠ±: <strong>+${timeBonus}</strong></p>
                <p>ğŸ’¡ æç¤ºå¥–åŠ±: <strong>+${hints * 50}</strong></p>
                <p>ğŸ”€ é‡æ’å¥–åŠ±: <strong>+${shuffles * 100}</strong></p>
            `;
            document.getElementById('gameOverModal').style.display = 'block';
            
            score = finalScore;
            updateUI();
        }

        function closeGameOver() {
            document.getElementById('gameOverModal').style.display = 'none';
        }

        function newGame() {
            clearInterval(gameTimer);
            isPaused = false;
            document.getElementById('pauseBtn').textContent = 'â¸ï¸ æš‚åœ';
            initializeGame();
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('remaining').textContent = totalPairs - matchedPairs;
            document.getElementById('hints').textContent = hints;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.getElementById('hintBtn').disabled = hints <= 0;
            document.getElementById('shuffleBtn').disabled = shuffles <= 0;
            
            // æ›´æ–°è¿›åº¦æ¡
            const progress = (matchedPairs / totalPairs) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        window.onload = () => {
            newGame();
        };

        // é˜²æ­¢é¡µé¢ç¼©æ”¾å½±å“æ¸¸æˆä½“éªŒ
        document.addEventListener('gesturestart', e => e.preventDefault());
        document.addEventListener('gesturechange', e => e.preventDefault());
    </script>
</body>
</html>
